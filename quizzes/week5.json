[
  {
    "id": "w5_1",
    "question": "Which TypeScript array method transforms each element and returns a new array?",
    "code": "",
    "choices": ["reduce()", "filter()", "map()", "forEach()"],
    "answerIndex": 2,
    "explanation": "map() applies a function to each element of an array and returns a new array of the same length."
  },
  {
    "id": "w5_2",
    "question": "Which method creates a new array with only elements that pass a given test?",
    "code": "",
    "choices": ["map()", "filter()", "reduce()", "sort()"],
    "answerIndex": 1,
    "explanation": "filter() returns a new array containing only elements that satisfy the provided condition."
  },
  {
    "id": "w5_3",
    "question": "Which method aggregates array values into a single value?",
    "code": "",
    "choices": ["map()", "filter()", "reduce()", "every()"],
    "answerIndex": 2,
    "explanation": "reduce() iterates over an array and combines all elements into a single value using an accumulator function."
  },
  {
    "id": "w5_4",
    "question": "What will be the output of the following TypeScript code?",
    "code": "const arr = [1, 2, 3];\nconsole.log(arr.map(x => x * 3));",
    "choices": ["[1, 2, 3]", "[3, 6, 9]", "[1, 4, 9]", "[3, 2, 1]"],
    "answerIndex": 1,
    "explanation": "The map() function multiplies each element by 3, resulting in [3, 6, 9]."
  },
  {
    "id": "w5_5",
    "question": "Why might you implement a custom map, filter, or reduce function?",
    "code": "",
    "choices": [
      "To work with arrays of primitive types only",
      "To work with user-defined data structures like lists or trees",
      "Because built-in methods are slower",
      "To avoid TypeScript errors"
    ],
    "answerIndex": 1,
    "explanation": "Custom implementations can operate on non-array structures like trees or graphs where built-in methods don't apply."
  },
  {
    "id": "w5_6",
    "question": "What is a key advantage of recursive solutions in TypeScript?",
    "code": "",
    "choices": [
      "They are always faster than loops",
      "They describe what should be done rather than how",
      "They reduce memory usage",
      "They don't require a return statement"
    ],
    "answerIndex": 1,
    "explanation": "Recursion is often more declarative, focusing on what needs to be done instead of step-by-step iteration."
  },
  {
    "id": "w5_7",
    "question": "What does the following TypeScript code demonstrate?",
    "code": "class Person {\n  readonly name: string;\n  age: number;\n  constructor(name: string, age?: number) {\n    this.name = name;\n    this.age = age;\n  }\n}",
    "choices": [
      "Primitive types",
      "User-defined classes and constructors",
      "TypeScript arrays",
      "Generic functions"
    ],
    "answerIndex": 1,
    "explanation": "The code defines a class with a constructor, demonstrating user-defined types in TypeScript."
  },
  {
    "id": "w5_8",
    "question": "Which TypeScript feature is being used here?",
    "code": "interface Logger {\n  log(message: string): void;\n}\nclass ConsoleLogger implements Logger {\n  log(message: string) {\n    console.log(message);\n  }\n}",
    "choices": [
      "Discriminated unions",
      "Classes",
      "Interfaces",
      "Generics"
    ],
    "answerIndex": 2,
    "explanation": "Interfaces define a contract that classes implement, enforcing a consistent structure."
  },
  {
    "id": "w5_9",
    "question": "Which TypeScript type pattern is shown below?",
    "code": "type Success<T> = { status: \"OK\"; result: T; };\ntype Fail = { status: \"Fail\"; reason: string; };\ntype ReturnType<T> = Success<T> | Fail;",
    "choices": [
      "Classes",
      "Interfaces",
      "Discriminated unions",
      "Generics only"
    ],
    "answerIndex": 2,
    "explanation": "ReturnType<T> is a discriminated union combining Success<T> and Fail, allowing type-safe handling of success and failure cases."
  },
  {
    "id": "w5_10",
    "question": "What will MapGeneric2([1,2,3], x=>x*x) return?",
    "code": "function MapGeneric2<T, R>(arr: Array<T>, fn: (val: T, index: number) => R): ReturnType<R[]> {\n  if(arr.length<=0) return {status: \"Fail\", reason: \"Empty array\"};\n  const result: Array<R> = [];\n  for (let i = 0; i < arr.length; i++) {\n    if(arr[i]==undefined) return {status: \"Fail\", reason: `Empty at index ${i}` };\n    result.push(fn(arr[i]!, i));\n  }\n  return {status: \"OK\", result: result};\n}\nconst res = MapGeneric2([1,2,3], x=>x*x);",
    "choices": [
      "{status: 'Fail', reason: 'Empty array'}",
      "{status: 'OK', result: [1,4,9]}",
      "[1,2,3]",
      "Throws runtime error"
    ],
    "answerIndex": 1,
    "explanation": "MapGeneric2 returns a discriminated union; here, the input is valid, so it returns {status: 'OK', result: [1,4,9]}."
  },
  {
    "id": "w5_11",
    "question": "Which TypeScript array operation allows chaining multiple operations?",
    "code": "",
    "choices": ["reduce()", "map()", "map() and filter()", "forEach()"],
    "answerIndex": 2,
    "explanation": "Methods like map() and filter() return arrays and can be chained to perform multiple transformations sequentially."
  },
  {
    "id": "w5_12",
    "question": "Which statement about currying is correct?",
    "code": "",
    "choices": [
      "Currying combines multiple functions into one",
      "Currying splits a multi-argument function into nested single-argument functions",
      "Currying only works with arrays",
      "Currying is a way to filter arrays"
    ],
    "answerIndex": 1,
    "explanation": "Currying transforms a function taking multiple arguments into a series of functions taking one argument each."
  },
  {
    "id": "w5_13",
    "question": "Why is immutability important in functional programming?",
    "code": "",
    "choices": [
      "It reduces runtime errors and side effects",
      "It makes code run faster",
      "It prevents recursion",
      "It allows using classes"
    ],
    "answerIndex": 0,
    "explanation": "Immutable objects do not change after creation, reducing side effects and making code more predictable."
  },
  {
    "id": "w5_14",
    "question": "Which of these is a pure function?",
    "code": "",
    "choices": [
      "A function that modifies a global variable",
      "A function that always returns the same output for the same input",
      "A function that logs data to the console",
      "A function that reads from a file"
    ],
    "answerIndex": 1,
    "explanation": "Pure functions do not modify external state and always return the same output for the same inputs."
  },
  {
    "id": "w5_15",
    "question": "What is function composition in TypeScript?",
    "code": "",
    "choices": [
      "Combining two functions so the output of one is the input of the next",
      "Writing multiple functions in the same file",
      "Calling reduce() inside map()",
      "Merging arrays using concat()"
    ],
    "answerIndex": 0,
    "explanation": "Function composition creates a new function by passing the output of one function as the input to another."
  },
  {
    "id": "w5_16",
    "question": "What does the And function do in this code?",
    "code": "function And<T>(f1:(a:T)=>boolean, f2:(a:T)=>boolean) {\n  return function(a:T){ return f1(a) && f2(a); }\n}",
    "choices": [
      "Runs f1 or f2 depending on a condition",
      "Runs both functions and returns true only if both are true",
      "Merges two arrays",
      "Filters objects based on price only"
    ],
    "answerIndex": 1,
    "explanation": "And combines two predicates and returns true only if both predicates return true for the input."
  },
  {
    "id": "w5_17",
    "question": "Which line filters products under 1000 that are in stock?",
    "code": "const products: Product[] = [\n  { id: 1, name: 'Laptop', price: 1200, inStock: true },\n  { id: 2, name: 'Phone', price: 800, inStock: false },\n  { id: 3, name: 'Tablet', price: 600, inStock: true }\n];",
    "choices": [
      "products.filter(x=>x.price<=1000).filter(x=>x.inStock)",
      "products.filter(x=>x.price<=1000 || x.inStock)",
      "products.map(x=>x.price<=1000 && x.inStock)",
      "products.reduce(x=>x.price<=1000 && x.inStock)"
    ],
    "answerIndex": 0,
    "explanation": "Chaining two filter() calls selects products meeting both conditions."
  },
  {
    "id": "w5_18",
    "question": "What does the Then function achieve?",
    "code": "function Then<X,Y,Z>(f:(a:Y)=>Z, g:(a:X)=>Y) {\n  return function(a:X){ return f(g(a)); }\n}",
    "choices": [
      "Composes two functions so f(g(x)) is applied",
      "Creates a nested class",
      "Filters arrays twice",
      "Executes asynchronous code"
    ],
    "answerIndex": 0,
    "explanation": "Then implements function composition, where the result of g(x) is passed into f."
  },
  {
    "id": "w5_19",
    "question": "Which statement about discriminated unions is true?",
    "code": "",
    "choices": [
      "They allow defining a type that can be one of multiple types distinguished by a literal",
      "They are classes",
      "They only work with numbers",
      "They replace interfaces"
    ],
    "answerIndex": 0,
    "explanation": "Discriminated unions combine multiple types using a literal property to distinguish between them."
  },
  {
    "id": "w5_20",
    "question": "Which TypeScript array operation is used to sum points of members only?",
    "code": "const onlyPoints = apiUsers.filter(x=>x.kind=='member').map(x=>x.points).reduce((acc, x)=> acc + x, 0);",
    "choices": [
      "filter() then map() then reduce()",
      "map() only",
      "reduce() only",
      "filter() only"
    ],
    "answerIndex": 0,
    "explanation": "This example first filters members, maps their points, then reduces to sum them."
  },
  {
    "id": "w5_21",
    "question": "Which is the correct syntax for a TypeScript type with optional property?",
    "code": "",
    "choices": [
      "type User = { id: number, name: string? }",
      "type User = { id: number, name?: string }",
      "type User = { id: number, name: optional string }",
      "type User = { id: number, name: string = optional }"
    ],
    "answerIndex": 1,
    "explanation": "Optional properties use the ? symbol: name?: string."
  },
  {
    "id": "w5_22",
    "question": "What does the code below illustrate?",
    "code": "type Admin = { kind: 'admin', id: number, name: string, permissions: string[] };\ntype Member = { kind: 'member', id: number, name: string, points: number };\ntype User = Admin | Member;",
    "choices": [
      "An array",
      "Discriminated unions",
      "Classes",
      "Generic function"
    ],
    "answerIndex": 1,
    "explanation": "User is a discriminated union that can be either Admin or Member."
  },
  {
    "id": "w5_23",
    "question": "Which statement is true about ReturnType<T>?",
    "code": "",
    "choices": [
      "It combines Success<T> and Fail types",
      "It only works for arrays",
      "It is a class",
      "It replaces interfaces"
    ],
    "answerIndex": 0,
    "explanation": "ReturnType<T> is a union type combining Success<T> and Fail to provide type-safe error handling."
  },
  {
    "id": "w5_24",
    "question": "Which statement about pure functions is correct?",
    "code": "",
    "choices": [
      "They depend on external variables",
      "They always return the same output for the same input",
      "They write to files or logs",
      "They modify global state"
    ],
    "answerIndex": 1,
    "explanation": "Pure functions have no side effects and consistently produce the same output for the same inputs."
  },
  {
    "id": "w5_25",
    "question": "What is the result of combining map(), filter(), and reduce() in sequence?",
    "code": "",
    "choices": [
      "A single aggregated value",
      "A new array after map, filtered, then reduced to a value",
      "Only the original array is modified",
      "It throws a runtime error"
    ],
    "answerIndex": 1,
    "explanation": "Chaining map, filter, and reduce allows stepwise transformations and final aggregation."
  },
  {
    "id": "w5_26",
    "question": "Which TypeScript feature allows generic types in functions?",
    "code": "",
    "choices": [
      "Interfaces",
      "Classes",
      "Generics",
      "Discriminated unions"
    ],
    "answerIndex": 2,
    "explanation": "Generics let you write functions that work with multiple types while preserving type safety."
  },
  {
    "id": "w5_27",
    "question": "What is the difference between MapGeneric and MapGeneric2?",
    "code": "",
    "choices": [
      "MapGeneric throws errors, MapGeneric2 returns a discriminated union",
      "MapGeneric uses reduce, MapGeneric2 uses map",
      "MapGeneric2 is synchronous, MapGeneric is asynchronous",
      "There is no difference"
    ],
    "answerIndex": 0,
    "explanation": "MapGeneric throws exceptions on error, whereas MapGeneric2 returns a ReturnType<T> to handle failures safely."
  },
  {
    "id": "w5_28",
    "question": "Which of these best describes currying?",
    "code": "",
    "choices": [
      "Breaking a function into smaller single-argument functions",
      "Transforming an array into a single value",
      "Filtering objects",
      "Chaining promises"
    ],
    "answerIndex": 0,
    "explanation": "Currying splits multi-argument functions into nested functions each taking a single argument."
  },
  {
    "id": "w5_29",
    "question": "What will the console output be?",
    "code": "const arr = [1,2,3,4,5];\nconsole.log(arr.filter(x => x % 2 === 0));",
    "choices": [
      "[1,3,5]",
      "[2,4]",
      "[1,2,3,4,5]",
      "[2,3,4]"
    ],
    "answerIndex": 1,
    "explanation": "The filter() method returns only even numbers: [2,4]."
  },
  {
    "id": "w5_30",
    "question": "Why is functional programming useful in TypeScript?",
    "code": "",
    "choices": [
      "It allows code to be more predictable, testable, and modular",
      "It replaces classes entirely",
      "It is required by TypeScript compiler",
      "It allows dynamic typing"
    ],
    "answerIndex": 0,
    "explanation": "Functional programming encourages pure functions, immutability, and function composition, improving predictability and maintainability."
  }
]
