[
  {
    "id": "w7_1",
    "question": "What does 'asynchronous' mean in JavaScript?",
    "code": "",
    "choices": [
      "Operations must complete before the next line executes",
      "Operations can occur at different times without blocking the main thread",
      "JavaScript uses multiple CPU threads to run tasks simultaneously",
      "Async code always runs faster than synchronous code"
    ],
    "answerIndex": 1,
    "explanation": "Asynchronous operations allow execution to continue while waiting for something to finish, without blocking the main thread."
  },
  {
    "id": "w7_2",
    "question": "What is the purpose of the event loop in JavaScript?",
    "code": "",
    "choices": [
      "To execute all code in parallel",
      "To schedule asynchronous callbacks when the call stack is empty",
      "To convert synchronous code into asynchronous code",
      "To store all globally declared variables"
    ],
    "answerIndex": 1,
    "explanation": "The event loop checks if the call stack is empty and then pulls callbacks from queues for execution."
  },
  {
    "id": "w7_3",
    "question": "Which queue has higher priority in JavaScript?",
    "code": "",
    "choices": [
      "Macrotask queue",
      "Microtask queue",
      "Render queue",
      "Timeout queue"
    ],
    "answerIndex": 1,
    "explanation": "Microtasks (Promises, queueMicrotask) always run before macrotasks (setTimeout, setInterval)."
  },
  {
    "id": "w7_4",
    "question": "What will this code output?",
    "code": "console.log('Start');\nsetTimeout(() => console.log('Middle'), 0);\nconsole.log('End');",
    "choices": [
      "Start, Middle, End",
      "Start, End, Middle",
      "Middle, Start, End",
      "End, Start, Middle"
    ],
    "answerIndex": 1,
    "explanation": "Even with 0 ms delay, the callback goes into the macrotask queue, so synchronous logs run first."
  },
  {
    "id": "w7_5",
    "question": "What is a callback function?",
    "code": "",
    "choices": [
      "A function that returns another function",
      "A function passed into another function to be executed later",
      "A function that must run synchronously",
      "A function that executes only on page load"
    ],
    "answerIndex": 1,
    "explanation": "Callbacks are executed when an asynchronous operation completes."
  },
  {
    "id": "w7_6",
    "question": "What does a Promise represent?",
    "code": "",
    "choices": [
      "A synchronous value that never changes",
      "A value that might be available now, later, or never",
      "A special type of callback",
      "A JSON response from a server"
    ],
    "answerIndex": 1,
    "explanation": "Promises wrap asynchronous results and resolve or reject in the future."
  },
  {
    "id": "w7_7",
    "question": "What will this code output?",
    "code": "Promise.resolve('A').then(v => console.log(v));\nconsole.log('B');",
    "choices": [
      "A then B",
      "B then A",
      "AB at the same time",
      "Throws an error"
    ],
    "answerIndex": 1,
    "explanation": "Promise .then callbacks go to the microtask queue, so 'B' logs first."
  },
  {
    "id": "w7_8",
    "question": "Which statement about fetch() is correct?",
    "code": "",
    "choices": [
      "fetch() blocks the thread until the server responds",
      "fetch() returns a Promise",
      "fetch() automatically retries failed requests",
      "fetch() always requires async/await"
    ],
    "answerIndex": 1,
    "explanation": "fetch() always returns a Promise and is non-blocking."
  },
  {
    "id": "w7_9",
    "question": "What does await do?",
    "code": "",
    "choices": [
      "Pauses the entire program",
      "Pauses only the current async function until the Promise resolves",
      "Converts async code into synchronous code",
      "Runs code in a separate thread"
    ],
    "answerIndex": 1,
    "explanation": "await pauses the async function, not the whole program."
  },
  {
    "id": "w7_10",
    "question": "What will this code output?",
    "code": "async function test() {\n  console.log('1');\n  await Promise.resolve();\n  console.log('2');\n}\ntest();\nconsole.log('3');",
    "choices": [
      "1, 2, 3",
      "1, 3, 2",
      "3, 1, 2",
      "2, 1, 3"
    ],
    "answerIndex": 1,
    "explanation": "await defers the continuation of the function as a microtask, so 3 logs before 2."
  },
  {
    "id": "w7_11",
    "question": "Which statement is true about async functions?",
    "code": "",
    "choices": [
      "They run synchronously by default",
      "They always return a Promise",
      "They make code faster",
      "They cannot use return"
    ],
    "answerIndex": 1,
    "explanation": "Any async function returns a Promise, regardless of what it returns internally."
  },
  {
    "id": "w7_12",
    "question": "What does .catch() handle in a Promise chain?",
    "code": "",
    "choices": [
      "Only syntax errors",
      "Only rejections",
      "Only network errors",
      "Both fulfilled and rejected values"
    ],
    "answerIndex": 1,
    "explanation": ".catch() handles rejected Promises in the chain."
  },
  {
    "id": "w7_13",
    "question": "What will this fetch() code log?",
    "code": "fetch('/data')\n  .then(r => r.json())\n  .then(d => console.log('done'));\nconsole.log('after fetch');",
    "choices": [
      "done then after fetch",
      "after fetch then done",
      "Both at the same time",
      "This produces an error"
    ],
    "answerIndex": 1,
    "explanation": "fetch is async; synchronous code runs first."
  },
  {
    "id": "w7_14",
    "question": "Which queue does Promise.then() use?",
    "code": "",
    "choices": [
      "Macrotask queue",
      "Render queue",
      "Microtask queue",
      "Timeout queue"
    ],
    "answerIndex": 2,
    "explanation": "Promises are added to the microtask queue."
  },
  {
    "id": "w7_15",
    "question": "Which of the following is NOT asynchronous?",
    "code": "",
    "choices": [
      "setTimeout",
      "fetch",
      "console.log",
      "Promise.then"
    ],
    "answerIndex": 2,
    "explanation": "console.log runs synchronously on the call stack."
  },
  {
    "id": "w7_16",
    "question": "What will this code output?",
    "code": "console.log('X');\nqueueMicrotask(() => console.log('Y'));\nconsole.log('Z');",
    "choices": [
      "X, Y, Z",
      "X, Z, Y",
      "Y, X, Z",
      "Z, X, Y"
    ],
    "answerIndex": 1,
    "explanation": "Microtasks run after the current synchronous execution finishes."
  },
  {
    "id": "w7_17",
    "question": "Which statement is true about Axios?",
    "code": "",
    "choices": [
      "It does not support Promises",
      "It automatically parses JSON",
      "It blocks the JavaScript thread",
      "It only works in Node.js"
    ],
    "answerIndex": 1,
    "explanation": "Axios auto-parses JSON and is built on Promises."
  },
  {
    "id": "w7_18",
    "question": "Which feature is a benefit of Axios?",
    "code": "",
    "choices": [
      "Always synchronous",
      "Automatic JSON parsing",
      "Built-in caching",
      "Guaranteed faster requests"
    ],
    "answerIndex": 1,
    "explanation": "Axios automatically parses JSON from responses."
  },
  {
    "id": "w7_19",
    "question": "What is a custom hook in React?",
    "code": "",
    "choices": [
      "A function used to update the DOM directly",
      "A function that stores reusable stateful logic",
      "A replacement for useState",
      "A way to create components"
    ],
    "answerIndex": 1,
    "explanation": "Custom hooks encapsulate reusable stateful behavior."
  },
  {
    "id": "w7_20",
    "question": "Which rule applies to custom hooks?",
    "code": "",
    "choices": [
      "They must run synchronously",
      "They must start with the word 'use'",
      "They must only return JSX",
      "They can only be used once per component"
    ],
    "answerIndex": 1,
    "explanation": "React requires hook names to start with use."
  },
  {
    "id": "w7_21",
    "question": "What will this code do inside a custom hook?",
    "code": "useEffect(() => {\n  console.log('run');\n}, []);",
    "choices": [
      "Run on every render",
      "Run only on component unmount",
      "Run only once on mount",
      "Never run"
    ],
    "answerIndex": 2,
    "explanation": "An empty dependency array makes useEffect run only once on mount."
  },
  {
    "id": "w7_22",
    "question": "What does return inside a useEffect callback represent?",
    "code": "",
    "choices": [
      "A cleanup function",
      "A Promise",
      "The next state update",
      "The component's return value"
    ],
    "answerIndex": 0,
    "explanation": "Returned functions from useEffect are used as cleanup logic."
  },
  {
    "id": "w7_23",
    "question": "What will this Promise chain output?",
    "code": "Promise.resolve('Hi')\n  .then(v => v + '!')\n  .then(v => console.log(v));",
    "choices": [
      "Hi",
      "Hi!",
      "undefined",
      "Throws an error"
    ],
    "answerIndex": 1,
    "explanation": "Each .then receives the previous resolved value."
  },
  {
    "id": "w7_24",
    "question": "What is the purpose of async/await?",
    "code": "",
    "choices": [
      "To make async code synchronous",
      "To make async code easier to read and write",
      "To speed up HTTP requests",
      "To replace Promises entirely"
    ],
    "answerIndex": 1,
    "explanation": "Async/await makes Promise-based code look synchronous but does not change behavior."
  },
  {
    "id": "w7_25",
    "question": "Which part runs FIRST in JavaScript?",
    "code": "",
    "choices": [
      "Microtasks",
      "Macrotasks",
      "Synchronous code",
      "Promise handlers"
    ],
    "answerIndex": 2,
    "explanation": "Synchronous code always runs first in the call stack."
  },
  {
    "id": "w7_26",
    "question": "What will this async function return?",
    "code": "async function x() {\n  return 5;\n}",
    "choices": [
      "5",
      "undefined",
      "A Promise that resolves to 5",
      "An error"
    ],
    "answerIndex": 2,
    "explanation": "Async functions always return a Promise, even with normal return values."
  },
  {
    "id": "w7_27",
    "question": "What will happen in this fetch example?",
    "code": "fetch('wrong-url')\n  .then(r => r.json())\n  .catch(e => console.log('error'));",
    "choices": [
      "The catch will never run",
      "The program will crash",
      "The catch will log 'error'",
      "JSON parsing will fix the URL error"
    ],
    "answerIndex": 2,
    "explanation": "fetch rejects on network errors, so catch runs."
  },
  {
    "id": "w7_28",
    "question": "What is true about the useFetch custom hook?",
    "code": "",
    "choices": [
      "It synchronously loads data",
      "It encapsulates fetching logic using useState and useEffect",
      "It can only fetch JSON files",
      "It must be used inside another hook"
    ],
    "answerIndex": 1,
    "explanation": "useFetch wraps fetching logic into a reusable custom hook using state and effects."
  },
  {
    "id": "w7_29",
    "question": "Which of the following will run last?",
    "code": "console.log('A');\nsetTimeout(() => console.log('B'), 0);\nPromise.resolve().then(() => console.log('C'));",
    "choices": [
      "A",
      "B",
      "C",
      "All run at the same time"
    ],
    "answerIndex": 1,
    "explanation": "Order: synchronous A → microtask C → macrotask B."
  },
  {
    "id": "w7_30",
    "question": "What is required for a function to be a valid React hook?",
    "code": "",
    "choices": [
      "It must return JSX",
      "It must start with 'use'",
      "It must be used at the bottom of the file",
      "It must be async"
    ],
    "answerIndex": 1,
    "explanation": "React identifies hooks by their naming convention: they must start with use."
  }
]
