[
  {
    "id": "w14_01",
    "question": "Week 14’s project combines which two main applications?",
    "choices": [
      "React + Django",
      "React TypeScript front-end + ASP.NET Core Minimal API back-end",
      "Vue + Spring Boot",
      "Angular + Flask"
    ],
    "answerIndex": 1,
    "explanation": "The notes describe a React+TypeScript client (ClientApp) and an ASP.NET Core API back-end."
  },
  {
    "id": "w14_02",
    "question": "What is a recommended folder structure for the MiniToDo project?",
    "choices": [
      "One folder with all files mixed together",
      "MiniToDo/ClientApp and MiniToDo/API as separate applications",
      "MiniToDo/src only",
      "MiniToDo/public only"
    ],
    "answerIndex": 1,
    "explanation": "The reader shows a root folder with two separate subprojects: ClientApp and API."
  },
  {
    "id": "w14_03",
    "question": "Which command is shown to scaffold a React+TypeScript app using Vite?",
    "choices": [
      "npm create vite@latest ClientApp -- --template react-ts",
      "dotnet new react",
      "npm init react",
      "npx create-react-app --ts"
    ],
    "answerIndex": 0,
    "explanation": "The notes use `npm create vite@latest ClientApp -- --template react-ts`."
  },
  {
    "id": "w14_04",
    "question": "What command starts the Vite dev server after installing dependencies?",
    "choices": [
      "npm run dev",
      "npm run build",
      "dotnet run",
      "node server.js"
    ],
    "answerIndex": 0,
    "explanation": "Vite projects typically run with `npm run dev`."
  },
  {
    "id": "w14_05",
    "question": "Which package is installed to add routing to the React app?",
    "choices": [
      "react-router-dom",
      "axios",
      "typeorm",
      "swashbuckle"
    ],
    "answerIndex": 0,
    "explanation": "The front-end section installs `react-router-dom` for routing."
  },
  {
    "id": "w14_06",
    "question": "Why does the example use the non-null assertion operator (!) with getElementById('root')?",
    "choices": [
      "To convert HTML to JSX",
      "To tell TypeScript the value is not null at runtime",
      "To make the element mutable",
      "To disable strict mode"
    ],
    "answerIndex": 1,
    "explanation": "TypeScript thinks getElementById can return null; `!` asserts it is non-null."
  },
  {
    "id": "w14_07",
    "question": "What is the main benefit of CSS modules (e.g., login.module.css) used in the notes?",
    "choices": [
      "They are required for React Router",
      "They scope styles to a component to avoid global collisions",
      "They automatically generate database tables",
      "They replace TypeScript"
    ],
    "answerIndex": 1,
    "explanation": "CSS modules scope class names to the component, reducing unintended style conflicts."
  },
  {
    "id": "w14_08",
    "question": "When rendering a list in React (map), why is a key prop needed?",
    "choices": [
      "To enable CORS",
      "To help React identify items for efficient updates/reconciliation",
      "To force the list to be sorted",
      "To prevent useEffect from running"
    ],
    "answerIndex": 1,
    "explanation": "Keys help React track list items across renders for efficient diffing and updates."
  },
  {
    "id": "w14_09",
    "question": "Which command creates a minimal ASP.NET Core web project in the back-end section?",
    "choices": [
      "dotnet new web -o API",
      "dotnet new mvc -o API",
      "dotnet new console -o API",
      "dotnet new razor -o API"
    ],
    "answerIndex": 0,
    "explanation": "The notes show `dotnet new web -o API` to create a minimal web app."
  },
  {
    "id": "w14_10",
    "question": "Which packages are added to use Entity Framework Core with SQLite?",
    "choices": [
      "Microsoft.EntityFrameworkCore, Microsoft.EntityFrameworkCore.Tools, Microsoft.EntityFrameworkCore.Sqlite",
      "react, react-dom",
      "express, cors",
      "Swashbuckle only"
    ],
    "answerIndex": 0,
    "explanation": "The API section adds EF Core packages including Tools and Sqlite provider."
  },
  {
    "id": "w14_11",
    "question": "What is the role of a DbContext in the MiniToDo API?",
    "choices": [
      "A UI router",
      "A database session/entry point providing DbSet<T> tables",
      "A CSS module wrapper",
      "A React hook"
    ],
    "answerIndex": 1,
    "explanation": "DbContext manages database access and exposes DbSet<T> properties for entities."
  },
  {
    "id": "w14_12",
    "question": "Why does the Todo model set Title = null! in C#?",
    "choices": [
      "To disable CORS",
      "To satisfy nullable reference type warnings while ensuring it will be set",
      "To mark it as optional in the database",
      "To prevent JSON serialization"
    ],
    "answerIndex": 1,
    "explanation": "null! tells the compiler you’ll initialize the property (e.g., via model binding/EF) even if it starts null."
  },
  {
    "id": "w14_13",
    "question": "What is the purpose of appsettings.json configuration entries for BackendUrls/ConnectionStrings/Frontend?",
    "choices": [
      "To store React components",
      "To configure runtime settings like URLs, database connection, and allowed front-end origin",
      "To generate migrations automatically",
      "To compile TypeScript"
    ],
    "answerIndex": 1,
    "explanation": "The notes add URLs, connection strings, and front-end URL for CORS in appsettings.json."
  },
  {
    "id": "w14_14",
    "question": "What is CORS used for in the integrated full-stack setup?",
    "choices": [
      "Allow the React front-end (different port) to call the API",
      "Cache React components",
      "Encrypt SQLite",
      "Compile C#"
    ],
    "answerIndex": 0,
    "explanation": "Since client and API run on different ports/origins, CORS must allow the front-end origin."
  },
  {
    "id": "w14_15",
    "question": "What do EF Core migrations do in the API setup?",
    "choices": [
      "Create/update the database schema based on model changes",
      "Create React routes",
      "Install npm packages",
      "Enable JSX"
    ],
    "answerIndex": 0,
    "explanation": "Migrations generate schema change scripts and apply them to the database (database update)."
  },
  {
    "id": "w14_16",
    "question": "What is the purpose of a generic IRepository<T> in the back-end section?",
    "choices": [
      "To handle UI navigation",
      "To centralize CRUD operations behind an abstraction",
      "To replace DbContext completely",
      "To generate CSS"
    ],
    "answerIndex": 1,
    "explanation": "The repository pattern provides a consistent abstraction for CRUD operations and testability."
  },
  {
    "id": "w14_17",
    "question": "Why is a service layer (e.g., ITodoService) introduced?",
    "choices": [
      "To store CSS",
      "To implement business logic and keep controllers thinner",
      "To remove the need for DTOs",
      "To bypass HTTP"
    ],
    "answerIndex": 1,
    "explanation": "Services contain business logic and coordinate repository calls, improving separation of concerns."
  },
  {
    "id": "w14_18",
    "question": "What is a DTO used for in the Todo API (CreateTodoDto/UpdateTodoDto)?",
    "choices": [
      "To define what data the API accepts for create/update",
      "To run migrations",
      "To configure Vite",
      "To define CSS scope"
    ],
    "answerIndex": 0,
    "explanation": "DTOs define request payloads (e.g., Title, IsDone) and prevent exposing full entity models directly."
  },
  {
    "id": "w14_19",
    "question": "What does app.MapControllers() do in the API Program.cs?",
    "choices": [
      "Registers controllers into DI",
      "Maps controller routes into the HTTP pipeline",
      "Enables React StrictMode",
      "Creates the SQLite database"
    ],
    "answerIndex": 1,
    "explanation": "MapControllers wires attribute-routed controllers so they can handle requests."
  },
  {
    "id": "w14_20",
    "question": "Why is builder.Services.AddControllers() needed when using controllers?",
    "choices": [
      "To enable the MVC controller framework in DI",
      "To enable Vite",
      "To enable React Router",
      "To enable SQLite Explorer"
    ],
    "answerIndex": 0,
    "explanation": "AddControllers registers MVC services so controllers can be discovered and invoked."
  },
  {
    "id": "w14_21",
    "question": "In the integration step, what is the purpose of useEffect(() => getTasks(), [])?",
    "choices": [
      "Run the fetch once when the component mounts",
      "Run the fetch on every render",
      "Run the fetch only when a checkbox toggles",
      "Disable rendering"
    ],
    "answerIndex": 0,
    "explanation": "An empty dependency array runs the effect on mount, suitable for initial data loading."
  },
  {
    "id": "w14_22",
    "question": "Why is UI status state (e.g., 'loading'/'idle') useful when fetching tasks?",
    "choices": [
      "It makes the network faster",
      "It lets the UI show loading indicators and disable controls appropriately",
      "It replaces CORS",
      "It removes the need for keys"
    ],
    "answerIndex": 1,
    "explanation": "Status state improves UX: show progress and prevent duplicate actions while requests are pending."
  },
  {
    "id": "w14_23",
    "question": "What is the purpose of disabling the checkbox while an update request is in progress?",
    "choices": [
      "To prevent sending multiple update requests at once",
      "To make React Router work",
      "To force reloading the page",
      "To ensure CSS modules compile"
    ],
    "answerIndex": 0,
    "explanation": "Disabling controls during updates reduces duplicate/inconsistent requests and improves consistency."
  },
  {
    "id": "w14_24",
    "question": "What does swagger provide when added to an API?",
    "choices": [
      "An interactive UI to explore and test API endpoints",
      "A database migration engine",
      "A React component library",
      "A TypeScript linter"
    ],
    "answerIndex": 0,
    "explanation": "Swagger (OpenAPI) documents endpoints and provides a UI for testing them."
  },
  {
    "id": "w14_25",
    "question": "Why is it useful to test API endpoints with a .rest file or Postman during development?",
    "choices": [
      "It replaces the need for controllers",
      "It verifies API behavior independently of the front-end",
      "It disables CORS checks in browsers",
      "It generates TypeScript types automatically"
    ],
    "answerIndex": 1,
    "explanation": "Testing endpoints directly helps confirm the back-end works before integrating the UI."
  }
]
